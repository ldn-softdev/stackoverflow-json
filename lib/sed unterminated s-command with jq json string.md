### Query: [sed unterminated `s' command with jq json string](https://stackoverflow.com/questions/59791136/sed-unterminated-s-command-with-jq-json-string)
([jump to the answer]())

Piggybacking off of [this question][1] I have a command (running in a Docker container) where I am trying to sed to replace an expression with a JSON string generated by jq.

Tiny backstory:

I have a whitelist of env vars in a file `tmp.txt`:

```
ENV_VAR_A
ENV_VAR_B
ENV_VAR_C
```

I use jq using the answer in the previous thread to generate a JSON string like this:

```
jq -Rn '[inputs | {(.): env[.]}] | add' ./tmp.txt
# GENERATES { "ENV_VAR_A": "a val", "ENV_VAR_B": "a val", "ENV_VAR_C": "a val"}
```

Amazing! Now I am trying to use sed (as a Docker `CMD`) to do replace something:

```
# CMD sed -i 's@{{SOME_PATTERN}}@'$( jq -Rn '[inputs | {(.): env[.]}] | add' ./etc/nginx/conf.d/env)'@' ./somefile
```

But I am getting:

```
sed: -e expression #1, char 22: unterminated `s' command
```

So something went wrong the substitution - but I am not nearly knowledgeable enough in shell to figure out how to fix it, I feel like I have to move some quotes/delimiters around, or maybe pipe my jq to something to "clean up" the json string before I substitute, but I'm not sure what.

Looking for some sed-fu, can anyone help?

  [1]: https://stackoverflow.com/questions/59778578/generating-a-json-map-containing-shell-variables-named-in-a-list/59779106?noredirect=1#comment105717845_59779106

### A:
from the comment, it follows that in fact OP is trying to replace values in the `HTML` source file:
>@peak it’s an HTML file, I’m replacing a placeholder with a JSON string.

In such case parsing and replacing in HTML with non-HTML tools would be non-idiomatic and horribly wrong solutions.
An idiomatic way for example, would be converting `HTML` into `JSON` (using a lossless converter) then apply all required modifications
in `JSON` and then convert back to `HTML`.

Now, there must be plently of `HTML` to `JSON` and back converters available, however I'll be using my favorite -
[**`jtm`**](https://github.com/ldn-softdev/jtm).
Once converted, it'll be possible to apply required replacements even given user's input format.

So, let's see it with this source `HTML`:
```bash
bash $ cat tmp.html
<!DOCTYPE html>
<html>
   <head>
       <title>HTML example</title>
       <meta charset="utf-8">
   </head>
   <body text="green">
       <p>
           some text with a substitution token: "ENV_VAR_A"
       </p>
       <p>
           some more text with another substitution token: "ENV_VAR_B"
       </p>
   </body>
</html>
bash $ 
```

The file with the replacement tokens is this:
```bash
bash $ cat tmp.txt
ENV_VAR_A
ENV_VAR_B
ENV_VAR_C
bash $ 
```

The solution based on [`jtc`](https://github.com/ldn-softdev/jtc) and [`jtm`](https://github.com/ldn-softdev/jtc) then is this:
```bash
bash $ <tmp.html jtm |\
                 jtc -w'<(.*)(ENV_VAR_.)(.*)>R:' -eu '<'tmp.txt sed -E '"s/(.*)/{\"\\1\": \"a val\"}/"'\| jtc -J / -w"'<{\$2}>l<V>v'" -T"'\"{\$1}{V}{\$3}\"'" \; |\
                 jtm
<!DOCTYPE html>
<html>
   <head>
      <title>HTML example</title>
      <meta charset="utf-8">
   </head>
   <body text="green">
      <p>some text with a substitution token: "a val"</p>
      <p>some more text with another substitution token: "a val"</p>
   </body>
</html>
bash $ 
```













